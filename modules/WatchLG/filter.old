#
# Do NOT edit this file as it is generated every time the module starts
# and provides the 'filter' function

filter() {
: FILTER_STATE=initial
: FILTER_DATE=2025-06-30T16:27:42+02:00
local debugs="@nodebug|@notrace|@alloff|@debug|@debug2|@trace"
local debfun

RULE=SetDebug

if [[ "$REPLY" =~ ($debugs) ]]
then
    debfun=${BASH_REMATCH[1]}	# Extract found matches
    trace "$funtag Debuging $debfun wanted"
    setdebug "$debfun"
    Pattern="$debfun"		# Let the post processor know the choice ...
    return 241   
fi
# ------------- End: debug settings ----------------------------------------
# 000-Ignore.rule
# Special ruleset to suppress UNTREATED logs
# i.e. it does NOT call 'inject' and returns exit code 254
#

# Catch [UNTREATED] for a legal login
RULE="LEGAL_LOGIN"
Pattern=': Accepted password for'
#--------------
if [[ "$REPLY" =~ "$Pattern" ]]; then return 240; fi

# Fails with IP-Pattern in PTR address for some bandits
RULE="BREAK-IN"
Pattern='POSSIBLE BREAK-IN ATTEMPT'
#--------------
#if [[ "$REPLY" =~ "$Pattern" ]]; then return 254; fi
# Give it a shot ...
if [[ "$REPLY" =~ "$Pattern" ]]; then inject; return $?; fi

# No IP address in log-line ...
RULE="Ignore-SSH-DH-mismatch" 
Pattern=': invalid public DH value:'
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then return 254; fi
# - 010-Scanner.rule
# Special ruleset to catch scanners
# i.e. it does call 'inject' with 5 (= $MAX_AFFAIRS) 
# The next occurence triggers a shoot-down
#
# Alternative to an entry in the module's superfluous_map file
RULE="Shodan-Scanner"
Pattern='.shodan.io\['
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject 5; return $?; fi

RULE="Censys-Scanner"
Pattern='.censys-scanner.com['
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject 5; return $?; fi

RULE="Cyberresilience-Scanner"
Pattern='.cyberresilience.io['
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject 5; return $?; fi

RULE="BinaryEdge-Scanner"
Pattern='.binaryedge.ninja['
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject 5; return $?; fi

#
# Catch all ...
#

#RULE="Generic_Scan"
#Pattern=': invalid format'
#---------------
#if [[ "$REPLY" =~ "$Pattern" ]]; then inject 4; return $?; fi

# REGEX of above ...
# Note that Pattern is not enclosed in double-quotes!
# This one makes a real REGEX (not string) match
RULE=Banner_exchange_invalid
Pattern=': banner exchange:.*: invalid format$'
#---------------
if [[ "$REPLY" =~ $Pattern ]]; then kickoff; return $?; fi

# - 090-Fakehost.rule -
## Note that Pattern is not enclosed in double-quotes!
# This one makes a real REGEX (not string) match
RULE=Fakehost
Pattern='reverse mapping checking getaddrinfo for .+ \[.+\] failed\.$'
#---------------
#if [[ "$REPLY" =~ $Pattern ]]; then inject 3; return $?; fi
if [[ "$REPLY" =~ $Pattern ]]; then CLASS=FAKEHOST; kickoff; return $?; fi

# Log message (sshd)
#2025-03-04T19:08:34.970 WatchLG[1551719]: [Loop: 1812] 'Mar  4 19:08:34 vmd123606.contaboserver.net sshd[1796852]: Address 171.251.23.55 maps to dynamic-ip-adsl.viettel.vn, but this does not map back to the address.'

RULE=Fakehost2
Pattern=', but this does not map back to the address.'
if [[ "$REPLY" =~ "$Pattern" ]]; then CLASS=FAKEHOST; kickoff; return $?; fi

RULE="Bad-SSH-Prot"
Pattern=': Bad protocol version identification'
#--------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject; return $?; fi

RULE="Bad-SSH-Nego"
Pattern=': Unable to negotiate with'
#--------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject; return $?; fi

RULE=root-login
Pattern=': Failed password for root'
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject 3; return $?; fi

RULE="NonPriv-login-pwd"
Pattern=': Failed password for invalid user'
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject; return $?; fi

RULE="NonPriv-login-none"
Pattern=': Failed none for invalid user'
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject; return $?; fi


RULE="Invalid-user"
Pattern=': Invalid user'
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject; return $?; fi

RULE="NonPriv-failed-existing"
Pattern=': Failed password for'
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject; return $?; fi

RULE="SSH-fatal-dispatch"
Pattern=': ssh_dispatch_run_fatal:'
#---------------
if [[ "$REPLY" =~ "$Pattern" ]]; then inject; return $?; fi
RULE=NO_RULE_MATCH
return 0
}
